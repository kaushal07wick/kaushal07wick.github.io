# OsmoGrep

![osmogrep](/images/osmogrep.png)

Codex-ClI and Claude Code can write code for almost any language, but real codebases need full compatibility and synced execution.

LLMs often hallucinate, and write code which is usually not correct or aligned with real use. For example, I tried using codex for `tinygrad` PRs, but it failed terribly and even after manual tweaks and repetitive prompting it didn't produce coherent code.

So, I made OsmoGrep. It is a deterministic, execution based system. 

## How is it different from other LLMs?

OsmoGrep uses full context of the implemented code or any new code, and writes a proper test for it. It then automatically runs full test-suite to check for coherent behaviour.
<br>
<br>
Also, traditional workflows break down in predictable ways:

* You eyeball a diff that looks fine but hides a behavioral change.
* Linting passes but runtime behavior shifts due to side effects.
* CI catches errors too late—after the commit, after the push.
* LLM “analysis” is often wrong because it doesn’t actually run your code.

[OsmoGrep](https://github.com/kaushal07wick/OsmoGrep) solves this by:

* analyzing code changes semantically (AST-level),
* creating safe ephemeral sandbox environments,
* executing tests/commands deterministically,
* capturing all runtime logs, timings, and behaviors,
* presenting clean, actionable summaries.


## **OsmoGrep Architecture**

 
## ![placeholder](#)


## **Pipeline Breakdown**

### **1. Snapshot Manager**

Before execution, OsmoGrep creates an isolated workspace:

* detects modified files
* creates ephemeral worktrees
* synchronizes configuration
* applies environment masking
* guarantees no mutation to your primary branch

This ensures you can run even destructive commands safely.

 

### **2. Semantic Diff Analyzer**

OsmoGrep’s diff engine is AST-aware, not string-based.

It identifies:

* function insertions
* function body mutations
* API signature changes
* control-flow restructuring
* dependency changes
* file creation/removal/movement

It reconstructs full functions using AST → S-expression → normalized code extraction.

 

## ![placeholder](#)

### **(Diagram Placeholder: AST Diff Flow)**

Suggested diagram flow:

```
Source Code -> Tree-sitter AST -> S-expression Normalizer ->
Change Classifier -> Impact Graph -> Function Reconstruction
```

 

### **3. Execution Sandbox**

This is where OsmoGrep shines.

It provides:

* isolated ephemeral workspace
* safe file-write redirection
* process-tree monitoring
* deterministic execution order
* optional containerization
* resource quotas (CPU/mem/network)

You get the truth about your code without the risk.

 

### **4. Test + Command Runner**

OsmoGrep integrates seamlessly with major ecosystems:

* Rust (`cargo test`)
* Python (`pytest`)
* JavaScript (`npm test`, `jest`)
* Go (`go test`)
* Shell scripts or custom commands

It tracks:

* which tests ran
* exit codes
* performance stats
* side effects
* temporary file usage
* spawned processes

Everything is transparent.

 

### **5. Observability Layer**

Every execution stream is captured:

* stdout
* stderr
* file writes
* timing metrics
* resource usage
* execution tree
* network access (optional)

This data is fed into both human-readable output and optional LLM summaries.

 

### **6. (Optional) LLM Reasoning Layer**

This layer does **not** guess.
It summarizes and reasons only from **ground truth logs** generated by the execution engine.

It can:

* explain failures
* summarize behavior changes
* generate impact reports
* suggest fixes or test coverage updates

But it never executes code by itself—it only interprets the real results.

 

## **Example Workflow**

Running OsmoGrep feels natural:

```bash
osmogrep analyze
```

Sample (placeholder) output:

```
Detected 4 modified files

Reconstructing AST...
✓ Parsed 9 modified functions

Spawning ephemeral workspace...
✓ Sandbox ready (/tmp/osmo-19283)

Running cargo test...
✓ test_parse_config (11ms)
✓ test_ok_path (5ms)
✖ test_invalid_path (FAIL)

Error Summary:
- expected Ok, got Err(NotFound)
- triggered by new File::open(...) in parse_config()

Impact:
- 3 downstream modules rely on parse_config()
```

 

## **Why OsmoGrep is Different**

### **Static Tools**

Miss runtime behavior.

### **LLM Agents**

Hallucinate execution results.

### **CI Systems**

Too late in the workflow.

### **Manual Testing**

Human error + incomplete coverage.

**OsmoGrep is the only tool that combines:**

* semantic diff intelligence
* deterministic sandbox execution
* real world observability
* grounded AI reasoning

into a single local-first developer workflow.

 

# **Use Cases**

### ✔️ Validate complex refactors

Prove your changes don't break downstream modules.

### ✔️ Investigate failing tests

Understand exactly which behavioral change caused it.

### ✔️ Run risky experiments safely

Sandbox ensures your repo and environment stay clean.

### ✔️ Explore code using execution intelligence

Generate impact reports or coverage-aware summaries.

 

# **Roadmap**

Planned upcoming additions:

* containerized runtime backend
* multi-language AST diffing
* per-test dependency graphs
* dynamic hooks for LLDB/GDB
* auto-fix PR generator
* streaming execution UI

 

# **Conclusion**

OsmoGrep redefines what an engineering tool should be.

Not static.
Not heuristic.
Not blind AI speculation.

But **deterministic, safe, deeply aware execution** built directly into your terminal.

If you care about correctness, reproducibility, and precision, OsmoGrep is the missing layer in your workflow.
